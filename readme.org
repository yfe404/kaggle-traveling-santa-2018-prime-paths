* Traveling Santa 2018 - Prime Paths

#+BEGIN_QUOTE
https://www.kaggle.com/c/traveling-santa-2018-prime-paths/leaderboard
#+END_QUOTE



** Best Approach so far 

What worked the best up until now was the TSP Solver (cf [[file:tsp_solver]]).

I tried various other approches: Greedy, GAs, Random Search, the tsp solver outperformed all of them
by far.


It seems that there is a positive correlation between the running time of the solver and the 
score of the solutions generated. 


We should consider building a distributed pipeline in which we would have several instances of TSP
generating solutions used as input in other algorithms such as local search. 


** Some Snippets (DO NOT USE - just for backup)


#+BEGIN_SRC sh
cat solution_in_kaggle_format.csv  | tail -n 197770 | tr "\n" " "  > path.tsp
cp path.tsp cpp/genetic_pool 
#+END_SRC


#+BEGIN_SRC python
import sys
import numpy as np
import pandas as pd
import sympy

def read_tour():
    tour = sys.stdin.read().split()[1:]
    tour = list(map(int, tour))
    if tour[-1] == 0: tour.pop()
    return tour

def score_tour(tour):
    cities = pd.read_csv('./cities.csv', index_col=['CityId'])
    df = cities.reindex(tour + [0]).reset_index()
    primes = list(sympy.primerange(0, len(cities)))
    df['prime'] = df.CityId.isin(primes).astype(int)
    df['dist'] = np.hypot(df.X - df.X.shift(-1), df.Y - df.Y.shift(-1))
    df['penalty'] = df['dist'][9::10] * (1 - df['prime'][9::10]) * 0.1
    return df.dist.sum() + df.penalty.sum()

def write_submission(tour, filename):
    assert set(tour) == set(range(len(tour)))
    pd.DataFrame({'Path': list(tour) + [0]}).to_csv(filename, index=False)



if __name__ == "__main__": 
    tour = read_tour()
    score = score_tour(tour)
    print(score)
    write_submission(tour, 'pool/{}.csv'.format(int(score)))
#+END_SRC


#+BEGIN_SRC sh
for i in $(seq 1 10000000); do cat linkern.tour | python process_tour.py && mv pool/*.csv /Users/yfe/Documents/kaggle-traveling-santa-2018-prime-paths/scripts/genetic_pool/ && sleep 10 ;done
#+END_SRC
